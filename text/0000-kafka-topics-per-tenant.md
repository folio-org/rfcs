
- Start Date: 2022-08-12
- RFC PR: (leave this empty)
- FOLIO Issue: (leave this empty)

# Kafka Topics Per Each Tenant

## Summary

The purpose of this RFC is to lay out the reasoning for creating Kafka topics using a different scheme other than what is currently employed; creating the same topic for each tenant. The recommendation is to create a single topic for each application concern. This will reduce the partition count needed for normal operations. This is the desired outcome for reducing the number of topics in the system. When a topic is created, it is composed of one or many partitions. Reducing the number of topics will reduce the number of partitions. Modules will be configured by default to use topics for each tenant, but alternate configuration would allow a module to produce to one topic for each application concern.

## Motivation
FOLIO should allow production of messages to single Kafka topics related to an application concern. Without this change, there are scaling and cost implications as the number of tenants increases in a FOLIO cluster.

- **Performance**: 
Similar to a database not having a theoretical limit on the number of rows/tables, Kafka does not have a limit on partition count. A major difference is that a partition is "heavier" than a row/table. Partitions have to be rebalanced, replicated with corresponding open server files for each partition. Partitions have an ongoing administrative cost while online. Creating numerous partitions like they are database rows/tables will spell disaster for an under-provisioned Kafka installation. This is why cloud providers ensure to have limits on partition counts. Provisioning a Kafka installation to support such a high partition count will be wasteful for FOLIO hosting providers. <p>
On the client side, buffers are created for each partition in memory. So a producer that interacts with very many thousands of partitions will consume more memory.
- **Cost**: Kafka's use in FOLIO is still limited, more FOLIO modules will continue to employ event driven techniques that will cause an explosion of partitions. For hosting providers that self host Kafka, more brokers or broker capacity will be needed to service load generated by the high number of partitions. For hosting providers who utilize cloud managed Kafka, cloud providers typically charge per partition or set limits on partition count for a particular broker size. For example, Confluent Cloud charges $13/partition/year with a maximum of 4096 partitions for one cluster. AWS charges $3679/year for a broker size with 4 vCPU and 16GB Memory and a soft limit of 1000 partitions per broker.

## Out of Scope
- Enabling tenant seperation within a module. Tenant seperation meaning "How do we prevent a tenant's data from being processed in place of another?", "How can we prevent a tenant module from seeing data from other tenants?"
- Moving forward with the [Temporary Kafka Security Solution](https://wiki.folio.org/x/YYVFAw).
- Countering module multi-versioning i.e. more than one version of a module is installed in FOLIO with tenants able to target specific versions of a module. **Module multi-versioning is supported by OKAPI but not for modules that interact directly via Kafka. This is an existing deficiency prior to this changes documented by this RFC.**


## Rationale and Alternatives
The main driver for this RFC is to reduce partition count within reasonable means. Creating single topics for all tenants would satisfy this goal. Further feature development on FOLIO can increase the partition count. Having single topics will reduce the multiplicative effects tenant counts has on topic counts and subsequently paritition counts. Here are other alternatives that were considered: 

- **Merging All Topics Into A Single Topic**:This would be a maintenance nightmare. Messages could be consumed in error because so many consumer groups will be present and would rely on application code to filter out irrelevant messages for any particular module.
- **Have A Single Topics For Each Module Area**: Module areas being Inventory, Acquisitions, Circulation etc. This shares the same pain as the previous point but to a lesser extent.
- **Reduce Partition Count For Each Topic**: Partition count should be tailored by a Kafka admin to suite the Kafka cluster involved; adjusting with load patterns and special cases that running applications might require. FOLIO has no guarantee that its configuration will be intact after its topics are initialized.<p> Reducing partition counts for each topic will produce decent impact on the problem illustrated by this document. But there is still a linear relationship between the number of tenants in a FOLIO cluster and the number of partitions in a Kafka cluster. Additional functionality which require the use of more topics will mean that partition counts in the Kafka cluster will grow with the addition of new tenants and release upgrades. Partition counts will be revisited sooner rather than later when reducing only partition configuration of a topic rather than a topic's existence. The scalability of FOLIO is still bound by Kafka to lesser extent.<p> Partitions on a topic in Kafka can only be increased and not decreased so the topic has to be dropped and recreated which will require some application disruption event.<p>
This alternative is not included in this RFC because administration of a Kafka installation owned by a hosting provider is out of FOLIO's control. Additionally, setting alternate default partition counts in folio-kafka-wrapper does not require the rigor of an RFC.

- **Create Tenant Collection Topics**: This approach involves creating another another set of topics similar to any other tenant. These new set of topics will store messages from all tenants in the FOLIO cluster and will be named in a similar scheme as regular tenant topics are named. The name of this tenant collection will match [A-Z][A-Z0-9]+. This will preserve Kafka subscription patterns during consumption. This approach has been selected for this RFC.


## Detailed Explanation/Design
To promote flexibility of FOLIO implementation patterns, the switch to single topics will be configurable via environment variables. The current naming scheme for topics created by folio-kafka-wrapper is like so:
>[environment].[namespace].[tenant].[eventtype]

An example: `folio.Default.diku.DI_COMPLETED`. The naming structure is preserved by declaring one more "tenant" where messages for all tenants on the cluster is received for an application concern. e.g. `folio.Default.ALL.DI_COMPLETED`.<p>
This will allow subscription definitions to remain the same. it will also allow steady migration to single topics for each module without worrying if a consuming module is listening to a single topic as well.
### Module Configuration
[folio-kafka-wrapper](https://github.com/folio-org/folio-kafka-wrapper) will check for the existence of an environment variable called `KAFKA_PRODUCER_TENANT_COLLECTION`. With this variable unset, the module will produce messages to topics for each tenant. if the variable is set to a value like `ALL`, the module will produce to one topic belonging to the "ALL tenant collection" e.g. `folio.Default.ALL.DI_COMPLETED`.<p>
In an ideal scenario, the value of the environment variable would be the same for all modules that need to make the switch to single topics.
### Consuming
In [folio-kafka-wrapper](https://github.com/folio-org/folio-kafka-wrapper), a sample of a subscription pattern is defined below

>folio\.Default\.\w{1,}\.DI_COMPLETED

where `folio` is the cluster name, `Default` is the namespace then a wildcard to capture tenant ids followed by the event type(`DI_COMPLETED`) that the topic is supposed to contain.
Subscriptions are created using this interface:
```
public static SubscriptionDefinition createSubscriptionDefinition(String env, String nameSpace, String eventType)
```
With the subscription pattern, consumers will be able to consume from tenant topics and single topics alike. Safeguards can be added to ensure that a message's ownership can be determined. These include:
- Enriching messages produced by folio-kafka-wrapper with a tenant id before the message is sent.
- Highlighting messages consumed that don't have a tenant id. Orphan messages can be logged partially or with the full contents. They can also be placed in a dead queue/topic for further review.

It is imperative that every message has a owner.

### Producing
In folio-kafka-wrapper, a topic name is generated by this interface
```
public static String formatTopicName(String env, String nameSpace, String tenant, String eventType)
```
This will generate a sample of a subscription pattern like so:
>folio\.Default\.tenant00001\.DI_COMPLETED

When `KAFKA_PRODUCER_TENANT_COLLECTION` environment variable is set, every variation to the tenant argument in the interface will always route to one "tenant". e.g.
>folio\.Default\.ALL\.DI_COMPLETED

Safeguards will be added to ensure that a message has a tenant id as one of its headers. It is imperative that every message has a owner.
## Implementation
- Changes will need to be made in folio-kafka-wrapper to implement safegaurds and watching for the new environment variable to exhibit different behaviour.
- FOLIO modules will reference the latest version of folio-kafka-wrapper.
## Migration To Single Topics
- FOLIO modules with latest version of folio-kafka-wrapper and `KAFKA_PRODUCER_TENANT_COLLECTION` set - are instantiated, new topics are created by module business logic.
- Existing tenant topics can be dropped.


## Risks and Drawbacks
- Lack of support in Kafka interactions for FOLIO's multi-versioning scheme, involving tenants using different versions of modules, can cause functional issues. Rate of issue occurrence does not increase with the changes detailed in this RFC. Functional issue occurrence is dependent on the breaking changes implemented in the varying versions. Multiple versions of a module will be consuming from the same topic and there are no guarantees about which module version will consume a message sourced from an incompatible version.
- Insights like "how many messages have yet to be processed for a tenant" will be harder to derive.
- Tenant topic settings will not be possible.
- [Temporary Kafka Security Solution](https://wiki.folio.org/x/YYVFAw) as described will no longer be possible. This solution is meant to be temporary as its name implies, a stop gap to a permanent solution. Creating topics for each tenant has been implemented and lightly enforced via the [folio-kafka-wrapper](https://github.com/folio-org/folio-kafka-wrapper) library. FOLIO is not able to enforce tenant security and isolation within its boundaries: the other two parts are not defined within FOLIO code, it is up to the hosting provider to implement. 
Kafka Topics per tenant is one part of a three part proposal to imbibe FOLIO tenant isolation in Kafka. More details about this proposal, [Temporary Kafka Security Solution](https://wiki.folio.org/x/YYVFAw). Only one of these items was completed.
  - Before this change, a Kafka administrator can set ACLs to Kafka topics so that a module can listen to only those tenants the module is enabled for in Okapi. When using topics with tenant collections, the ACLs can no longer be used on a tenant basis.

## Frequently Asked Questions
- Should we ensure one tenant doesn't hog resources with a large number of messages which delays processing for other tenants with messages in a single topic?
  - Within a single topic, there are still multiple partitions where messages will tend to be distributed evenly. So a single topic does not mean a strict single queue with first in, first out. With that said, there are strategies that can be employed by a Kafka administrator when there is high offset lag or hot partitions in a cluster.

- Should we ensure that FOLIO's multi-versioning scheme is applied in Kafka as well?
  - Multi-versioning is not supported with direct interaction with Kafka currently. This is out of scope for this RFC to resolve.

## Related Concerns

### Why Finishing The Temporary Kafka Security Solution Will Have Cascading Effects
Attempting to implement the other two parts of the [Temporary Kafka Security Solution](https://wiki.folio.org/x/YYVFAw) would probably force a decision to have dedicated modules instances to retain distinct credentials needed to access Kafka thereby raising FOLIO's cost-to-host. Having modules per tenant is cost prohibitive, causes inefficient use of some resources and overwhelm other resources e.g. increasing database connections for each module instance.<p> At the time of writing, FOLIO's own release infrastructure does not have modules per tenant or Kafka security configurations as described by the Temporary Kafka Security Solution. Another consequence would be the need for a process to create Kafka users when a tenant is installed in okApi.<p> A representation of Kafka ACLs would also need to be created for FOLIO developers to modify definitions for which modules can access any particular topic. These items are not defined by the temporary solution and is left for a hosting provider to figure out.

### Why Supporting Module Multi-Versioning Via Topic Versioning Is Not Desirable
FOLIO's multi-versioning scheme is still a gap not covered by this change. An approach could be to create topics for each module version. This will allow specific messages to be delivered to specific versions without causing a partition count explosion when a new tenant is installed. Topics belonging to older modules versions can be removed safely.

>Example:<p>
if V1 of Module A exists and V1 and V2 of Module B exists. Each will have their own versioned topics; Module A:V1, Module B:V1, Module B:V2.

There are edge cases with this approach that will have to be fleshed out. After these edge cases are covered, I believe a complex solution would have been built.
- How will V1 of module A know all the versions of other modules that exists and which topic is applicable for tenant message?
- How will V1 of module A know that V2 of module B has been recently installed and should use V2 topic to send a message for a specific tenant?
- Are we saying there is a one-to-one relationship between a versioned module and a versioned topic? Is the version of the topic independent from the version of the module? modules don't "own" topics for every case. Some modules are sole producers of a topic while other topics can have multiple producers.
- Module dependencies currently described in module descriptors inform the system of other versions that are compatible when communicating via a REST interface. Are we going to define module dependencies when communicating via events? Does that undercut the loose coupling that Kafka provides?

Some hosting providers do not employ FOLIO's multi-versioning too often. FOLIO clusters are usually within the scope of a flower release with an upgrade event to shift to another flower release. Nonetheless, multi-versioning is available and there are no guarantees that it will not be used. All of work will be applied to a feature that may not be used often.

### Why Supporting Module Multi-Versioning Via Message Versioning Is Not Desirable
Another approach to counter FOLIO's multi-versioning is to version messages produced into topics. Messages would have a special header that will denote the version of the message. Logic could be applied in a module to discard messages that are not compatible with the module. Modules have different versions would have to be in their own consumer group so that each version can receive a copy of a versioned message.
There are edge cases with this approach to think about:
- FOLIO modules are not tenant-aware i.e. a module does not know which tenants it can processed, OR which tenant are installed in okApi for its version. This would help in discarding messages easily - tenant id exists as a header in the Kafka message.
- Modules need a mechanism to allow compatibility for compatible future versions of a message without a code change. For example, V1 of module A emits V1 message that is consumed by V1 of module B. V2 of module A is introduced which emits a V2 message. How will V1 of module B consume the new version (which is functionally correct to consume, imagine if an extra property is added to the message) if it is strictly coded to accept V1. Will semantic versioning be introduced?
- It would be prudent to maintain an event type registry that will maintain event type version and their schemas. It is not a rule that there must be only one producer into a topic. For example, V1 of module A and V2 of module B can produce V1 of a message into a topic. Since modules are meant to have independent development cycles, it will be important to ensure that the next version of module A and B do not declare the same version of a message but with different schemas.